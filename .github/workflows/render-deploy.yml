name: 10-auto-Deploy to Render (queued, latest-wins)

on:
  push:
    branches: [ main ]
    paths:
      - "app.py"
      - "shared/**"
      - "modules/**"
      - "config/**"
      - "scripts/**"
      - "requirements*.txt"
      - "pyproject.toml"
      - "poetry.lock"
      - "Dockerfile"
      - ".dockerignore"
  workflow_dispatch: {}

jobs:
  deploy:
    concurrency:
      group: render-deploy-main
      cancel-in-progress: false
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (shallow)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      # Ensure Node has what we need for the inline script
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # Wait until there is no active Render deploy (do NOT cancel anything)
      - name: Wait for lane (no cancel)
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          RENDER_SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }}
        run: |
          cat > wait_render.js <<'JS'
          const fetch = (...a)=>import('node-fetch').then(({default:f})=>f(...a));
          const key = process.env.RENDER_API_KEY;
          const svc = process.env.RENDER_SERVICE_ID;
          if(!key || !svc){ console.log('No API key/service id; skipping wait.'); process.exit(0); }

          const hdr = { 'accept': 'application/json', 'authorization': `Bearer ${key}` };
          const active = s => ['build_in_progress','update_in_progress','live_update_in_progress','build_queued','update_queued'].includes((s||'').toLowerCase());

          async function req(url, opts={}) {
            const r = await fetch(url, { ...opts, headers: hdr });
            if(!r.ok) throw new Error(`${url} ${r.status}`);
            return r.json();
          }

          async function latest(){
            const list = await req(`https://api.render.com/v1/services/${svc}/deploys?limit=1`);
            return list && list[0];
          }

          async function waitClear(){
            const start = Date.now();
            const timeoutMs = 30 * 60 * 1000; // give Render plenty of time
            for(;;){
              const d = await latest();
              const st = d?.status || d?.deploy?.status || '';
              if(active(st)){
                // just wait; do not cancel in-flight work
                await new Promise(r=>setTimeout(r, 5000));
                if(Date.now()-start > timeoutMs) throw new Error('Timeout waiting for lane');
              } else {
                console.log('Lane clear:', st || 'none');
                return;
              }
            }
          }

          waitClear().catch(e=>{ console.error(e.message); process.exit(1); });
          JS
          npm init -y >/dev/null
          npm install node-fetch@3 >/dev/null
          node wait_render.js

      - name: Trigger Render deploy
        env:
          HOOK: ${{ secrets.RENDER_DEPLOY_HOOK }}
        run: curl -fsS -X POST "$HOOK"
