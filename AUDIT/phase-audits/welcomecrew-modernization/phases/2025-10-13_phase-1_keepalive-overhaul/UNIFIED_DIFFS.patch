diff --git a/app.py b/app.py
index 2623e23..afa5c3a 100644
--- a/app.py
+++ b/app.py
@@ -14,6 +14,8 @@ from config.runtime import (
     get_env_name,
     get_bot_name,
     get_watchdog_stall_sec,
+    get_watchdog_disconnect_grace_sec,
+    get_keepalive_interval_sec,
     get_command_prefix,
 )
 from shared import socket_heartbeat as hb
@@ -47,27 +49,41 @@ _watchdog_started = False  # guard to start once
 @bot.event
 async def on_ready():
     global _watchdog_started
-    hb.touch()  # mark as fresh as soon as we're ready
+    hb.note_ready()  # mark as fresh as soon as we're ready
     log.info(f"Bot ready as {bot.user} | env={get_env_name()} | prefix={BOT_PREFIX}")
 
     if not _watchdog_started:
         stall = get_watchdog_stall_sec()
+        keepalive = get_keepalive_interval_sec()
+        disconnect_grace = get_watchdog_disconnect_grace_sec(stall)
         # small grace so the gateway settles before we start enforcing staleness
         await asyncio.sleep(5)
         asyncio.create_task(
-            watchdog.run(hb.age_seconds, stall_after_sec=stall, check_every=30)
+            watchdog.run(
+                hb.age_seconds,
+                stall_after_sec=stall,
+                check_every=keepalive,
+                state_probe=hb.snapshot,
+                disconnect_grace_sec=disconnect_grace,
+                latency_probe=lambda: getattr(bot, "latency", None),
+            )
         )
         _watchdog_started = True
-        log.info(f"Watchdog started (stall_after={stall}s)")
+        log.info(
+            "Watchdog started (stall_after=%ss, interval=%ss, disconnect_grace=%ss)",
+            stall,
+            keepalive,
+            disconnect_grace,
+        )
 
 # Touch heartbeat on a few high-volume signals.
 @bot.event
 async def on_connect():
-    hb.touch()
+    hb.note_connected()
 
 @bot.event
 async def on_resumed():
-    hb.touch()
+    hb.note_connected()
 
 @bot.event
 async def on_message(message: discord.Message):
@@ -89,6 +105,11 @@ except Exception:
     pass
 
 
+@bot.event
+async def on_disconnect():
+    hb.note_disconnected()
+
+
 # ---- Minimal CoreOps smoke command ------------------------------------------
 
 @bot.command(name="ping")
diff --git a/config/runtime.py b/config/runtime.py
index d9df784..960a583 100644
--- a/config/runtime.py
+++ b/config/runtime.py
@@ -2,7 +2,7 @@
 from __future__ import annotations
 
 import os
-from typing import Iterable, List
+from typing import Iterable, List, Optional
 
 
 def get_port(default: int = 10000) -> int:
@@ -46,11 +46,69 @@ def get_admin_ids() -> List[int]:
     return ids
 
 
-def get_watchdog_stall_sec(default: int = 120) -> int:
+def _coerce_int(value: Optional[str], fallback: int) -> int:
     try:
-        return int(os.getenv("WATCHDOG_STALL_SEC", str(default)))
-    except ValueError:
+        if value is None:
+            raise TypeError
+        return int(value)
+    except (TypeError, ValueError):
+        return fallback
+
+
+def get_keepalive_interval_sec(
+    default_prod: int = 360,
+    default_nonprod: int = 60,
+) -> int:
+    """
+    Interval (seconds) between watchdog keepalive checks.
+
+    Defaults:
+        - prod-like envs → 360s (6 min) within the 300–600s window.
+        - dev/test/stage → 60s for quicker feedback.
+    Override via KEEPALIVE_INTERVAL_SEC.
+    """
+
+    env = get_env_name().lower()
+    fallback = default_nonprod if env in {"dev", "development", "test", "qa", "stage"} else default_prod
+
+    override = os.getenv("KEEPALIVE_INTERVAL_SEC")
+    if override is not None:
+        return _coerce_int(override, fallback)
+
+    return fallback
+
+
+def get_watchdog_stall_sec(default: Optional[int] = None) -> int:
+    """
+    Returns the watchdog stall threshold.
+
+    If WATCHDOG_STALL_SEC is unset we derive it from the keepalive cadence:
+        stall = keepalive * 3 + 30 (matches the legacy watchdog heuristics)
+    """
+
+    override = os.getenv("WATCHDOG_STALL_SEC")
+    if override is not None:
+        fallback = default if default is not None else get_keepalive_interval_sec() * 3 + 30
+        return _coerce_int(override, fallback)
+
+    keepalive = get_keepalive_interval_sec()
+    derived = keepalive * 3 + 30
+    if default is not None:
+        return derived if derived else default
+    return derived
+
+
+def get_watchdog_disconnect_grace_sec(default: Optional[int] = None) -> int:
+    """Grace window (seconds) while disconnected before forcing a restart."""
+
+    override = os.getenv("WATCHDOG_DISCONNECT_GRACE_SEC")
+    if override is not None:
+        fallback = default if default is not None else get_watchdog_stall_sec()
+        return _coerce_int(override, fallback)
+
+    if default is not None:
         return default
+    return get_watchdog_stall_sec()
 
 
 def get_command_prefix(default: str = "rec") -> str:
diff --git a/shared/socket_heartbeat.py b/shared/socket_heartbeat.py
index 58cdce0..2d43e78 100644
--- a/shared/socket_heartbeat.py
+++ b/shared/socket_heartbeat.py
@@ -2,56 +2,104 @@ from __future__ import annotations
 
 # shared/socket_heartbeat.py
 """
-Lightweight gateway heartbeat tracker.
+Gateway heartbeat tracker + connection state used by the watchdog and
+health endpoints.
 
 Usage:
     from shared import socket_heartbeat as hb
 
+    hb.note_connected()  # on_connect / on_resumed
+    hb.note_ready()      # on_ready
+    hb.note_disconnected()  # on_disconnect
+
     # on *every* gateway event (READY, MESSAGE_CREATE, etc.)
     hb.touch()
 
     # health probes / watchdog
-    age = await hb.age_seconds()  # how long since last gateway activity
+    age = await hb.age_seconds()            # seconds since last event
+    snap = hb.snapshot()                    # consistent view for watchdog
 
 Design:
 - Single in-process tracker (module-level singleton).
-- Async-safe; uses an asyncio.Lock so calls from multiple tasks are fine.
-- Cheap: only stores a monotonic timestamp.
+- All mutation helpers are sync for the hot discord.py paths.
+- Stores monotonic timestamps to avoid clock skew surprises.
 """
 
-import asyncio
+from dataclasses import dataclass
 import time
 from typing import Optional
 
 
+@dataclass(frozen=True)
+class GatewaySnapshot:
+    """Immutable view of the gateway state used by watchdog logic."""
+
+    connected: bool
+    last_event_age: float
+    last_ready_age: Optional[float]
+    disconnect_age: Optional[float]
+    last_event_ts: float
+    last_ready_ts: Optional[float]
+    last_disconnect_ts: Optional[float]
+
+
 class _Heartbeat:
     def __init__(self) -> None:
-        self._lock = asyncio.Lock()
-        self._last_monotonic: float = time.monotonic()
-
-    async def _set_now(self) -> None:
-        async with self._lock:
-            self._last_monotonic = time.monotonic()
+        now = time.monotonic()
+        self._last_event_ts: float = now
+        self._last_ready_ts: Optional[float] = None
+        self._last_disconnect_ts: Optional[float] = None
+        self._connected: bool = False
 
     def touch_now(self) -> None:
-        """
-        Fast, sync variant for hot paths (discord.py event handlers are fine).
-        """
-        self._last_monotonic = time.monotonic()
+        """Fast, sync variant for hot paths (discord.py event handlers)."""
+
+        now = time.monotonic()
+        self._last_event_ts = now
+
+    def note_connected(self) -> None:
+        now = time.monotonic()
+        self._connected = True
+        self._last_event_ts = now
+
+    def note_ready(self) -> None:
+        now = time.monotonic()
+        self._connected = True
+        self._last_event_ts = now
+        self._last_ready_ts = now
+
+    def note_disconnected(self) -> None:
+        now = time.monotonic()
+        self._connected = False
+        self._last_disconnect_ts = now
+
+    def snapshot(self) -> GatewaySnapshot:
+        now = time.monotonic()
+        last_event_age = max(0.0, now - self._last_event_ts)
+        last_ready_age = (
+            None if self._last_ready_ts is None else max(0.0, now - self._last_ready_ts)
+        )
+        disconnect_age = (
+            None
+            if self._last_disconnect_ts is None
+            else max(0.0, now - self._last_disconnect_ts)
+        )
+        return GatewaySnapshot(
+            connected=self._connected,
+            last_event_age=last_event_age,
+            last_ready_age=last_ready_age,
+            disconnect_age=disconnect_age,
+            last_event_ts=self._last_event_ts,
+            last_ready_ts=self._last_ready_ts,
+            last_disconnect_ts=self._last_disconnect_ts,
+        )
 
     async def age_seconds(self) -> float:
-        """
-        Returns seconds since the last touch(). Non-blocking read.
-        """
-        # Read without lock; slight race is fine for health purposes.
-        last = self._last_monotonic
+        last = self._last_event_ts
         return max(0.0, time.monotonic() - last)
 
     async def last_timestamp(self) -> float:
-        """
-        Returns the raw monotonic timestamp of the last activity.
-        """
-        return self._last_monotonic
+        return self._last_event_ts
 
 
 # Singleton instance (module-level)
@@ -62,22 +110,45 @@ _hb = _Heartbeat()
 
 def touch() -> None:
     """
-    Record 'now' as the last time we saw any gateway activity.
+    Record "now" as the last time we saw any gateway activity.
     Prefer this sync function in event handlers for minimal overhead.
     """
+
     _hb.touch_now()
 
 
+def note_connected() -> None:
+    """Flag the gateway as connected (on_connect/on_resumed)."""
+
+    _hb.note_connected()
+
+
+def note_ready() -> None:
+    """Capture the READY event."""
+
+    _hb.note_ready()
+
+
+def note_disconnected() -> None:
+    """Flag the gateway as disconnected (on_disconnect)."""
+
+    _hb.note_disconnected()
+
+
+def snapshot() -> GatewaySnapshot:
+    """Return a cheap, immutable snapshot for watchdog checks."""
+
+    return _hb.snapshot()
+
+
 async def age_seconds() -> float:
-    """
-    Seconds since the last gateway activity.
-    """
+    """Seconds since the last gateway activity."""
+
     return await _hb.age_seconds()
 
 
 async def last_timestamp() -> float:
-    """
-    Monotonic timestamp of last activity.
-    """
+    """Monotonic timestamp of last activity."""
+
     return await _hb.last_timestamp()
 
diff --git a/shared/watchdog.py b/shared/watchdog.py
index bb9bd58..da90f6e 100644
--- a/shared/watchdog.py
+++ b/shared/watchdog.py
@@ -2,11 +2,13 @@ from __future__ import annotations
 
 # shared/watchdog.py
 """
-Simple watchdog that restarts the container if the gateway heartbeat
-goes stale for longer than WATCHDOG_STALL_SEC.
+Watchdog loop mirrored from the battle-tested legacy bots.
 
-It runs as an asyncio background task:
-    asyncio.create_task(watchdog.run(hb.age_seconds, 120))
+Key behaviors:
+- Polls the gateway heartbeat age at the configured keepalive cadence.
+- If connected but idle for too long ("zombie"), restarts once latency also
+  looks bad or is unavailable.
+- If disconnected longer than the allowed grace, restarts immediately.
 
 On Render the process exit will trigger a clean restart.
 """
@@ -16,36 +18,102 @@ import logging
 import os
 import sys
 import time
-from typing import Awaitable, Callable
+from typing import Awaitable, Callable, Optional
+
+from shared.socket_heartbeat import GatewaySnapshot
 
 ProbeFn = Callable[[], Awaitable[float]]
+StateProbe = Callable[[], GatewaySnapshot]
+LatencyProbe = Callable[[], Optional[float]]
+
 log = logging.getLogger("watchdog")
 
 
-async def run(heartbeat_probe: ProbeFn, stall_after_sec: int = 120, check_every: int = 30) -> None:
+async def run(
+    heartbeat_probe: ProbeFn,
+    *,
+    stall_after_sec: int = 120,
+    check_every: int = 30,
+    state_probe: Optional[StateProbe] = None,
+    disconnect_grace_sec: Optional[int] = None,
+    latency_probe: Optional[LatencyProbe] = None,
+) -> None:
     """
-    Periodically checks the age of the last gateway event.
-    If it exceeds stall_after_sec, logs and terminates the process.
+    Periodically checks the age of the last gateway event using the
+    proven logic from the MM/WC watchdogs.
+
+    Args:
+        heartbeat_probe: coroutine returning age since the last event.
+        stall_after_sec: treat heartbeat as zombie beyond this age.
+        check_every: watchdog loop cadence.
+        state_probe: optional snapshot provider for connection state.
+        disconnect_grace_sec: grace window before exiting while disconnected.
+        latency_probe: optional callable returning gateway latency in seconds.
     """
-    log.info(f"[watchdog] active: stall_after={stall_after_sec}s, interval={check_every}s")
+
+    disconnect_limit = disconnect_grace_sec or stall_after_sec
+    log.info(
+        "[watchdog] active: stall_after=%ss, interval=%ss, disconnect_grace=%ss",
+        stall_after_sec,
+        check_every,
+        disconnect_limit,
+    )
     last_ok: float = time.monotonic()
 
     while True:
         try:
             age = await heartbeat_probe()
-            if age <= stall_after_sec:
-                last_ok = time.monotonic()
+            snapshot = state_probe() if state_probe else None
+            connected = snapshot.connected if snapshot else age <= stall_after_sec
+            disconnect_age = snapshot.disconnect_age if snapshot else None
+
+            if connected:
+                if age <= stall_after_sec:
+                    last_ok = time.monotonic()
+                else:
+                    latency = None
+                    if latency_probe:
+                        try:
+                            latency = latency_probe()
+                        except Exception as exc:
+                            log.debug("[watchdog] latency probe failed: %s", exc)
+
+                    since_ok = round(time.monotonic() - last_ok, 1)
+                    log_args = {
+                        "age": f"{age:.1f}",
+                        "stall": stall_after_sec,
+                        "since_ok": since_ok,
+                        "latency": latency,
+                    }
+                    if latency is None or latency > 10.0:
+                        log.error(
+                            "[watchdog] zombie: age=%(age)s>%(stall)s, "
+                            "since_ok=%(since_ok)s, latency=%(latency)s — exiting",
+                            log_args,
+                        )
+                        sys.stdout.flush()
+                        sys.stderr.flush()
+                        os._exit(1)
+                    else:
+                        log.warning(
+                            "[watchdog] heartbeat old but latency healthy "
+                            "(age=%(age)s, latency=%(latency)s) — skipping restart",
+                            log_args,
+                        )
             else:
-                since_ok = round(time.monotonic() - last_ok, 1)
-                log.error(
-                    f"[watchdog] heartbeat stale ({age:.1f}s > {stall_after_sec}s) "
-                    f"no activity for {since_ok}s — exiting"
-                )
-                sys.stdout.flush()
-                sys.stderr.flush()
-                os._exit(1)
+                down_for = disconnect_age if disconnect_age is not None else age
+                if down_for > disconnect_limit:
+                    log.error(
+                        "[watchdog] disconnected for %.1fs (limit=%ss) — exiting",
+                        down_for,
+                        disconnect_limit,
+                    )
+                    sys.stdout.flush()
+                    sys.stderr.flush()
+                    os._exit(1)
+
         except Exception as exc:
-            log.exception(f"[watchdog] error during probe: {exc}")
+            log.exception("[watchdog] error during probe: %s", exc)
 
         await asyncio.sleep(check_every)
 
